reparation=function(t){ #Products in reparation
sum(P<=t)-sum(R<=t)
}
reparation(10000)
Disp=(scenarios-sapply(t,reparation))/scenarios
plot(t,Disp, type = 'l' ,xlim=c(0, 5*10e3), ylim=c(0.5,1), main='Disponibilité de produit dans le temps')
(1/rateU)/(1/rateU+1/rateD) #Debe converger a este valor.
?rbeta
?dnorm
pnorm(0.025)
qnorm(0.025)
qnorm(1-0.025)
pi=11/20
n=20
z=qnorm(1-0.025)
pi-z*sqrt(pi*(1-pi)/n)
pi+z*sqrt(pi*(1-pi)/n)
?qbeta()
qbeta(0.025,16,14)
qbeta(0.975,16,14)
0.975+0.025
factorial(20) / (factorial(11) * (factorial(9)))
com=factorial(20) / (factorial(11) * (factorial(9)))
log_likelihood_Heads=function(pi){
log(com)+11*log(pi)+9*log(1-pi)
}
lLHeads=apply(pis,log_likelihood_Heads)
lLHeads=rapply(pis,log_likelihood_Heads)
lLHeads=lapply(pis,log_likelihood_Heads)
lLHeads=sapply(pis,log_likelihood_Heads)
pis=seq(0,1,100)
lLHeads=sapply(pis,log_likelihood_Heads)
plot(pis,lLHeads)
log_likelihood_Heads(0)
pis=seq(0.01,1,100)
com=factorial(20) / (factorial(11) * (factorial(9)))
log_likelihood_Heads=function(pi){
log(com)+11*log(pi)+9*log(1-pi)
}
log_likelihood_Heads(0)
lLHeads=sapply(pis,log_likelihood_Heads)
plot(pis,lLHeads)
sapply(pis,log_likelihood_Heads)
pis=seq(0.01,1,100)
pis=seq(0.01,1,0.001)
pis=seq(0.01,1,0.01)
lLHeads=sapply(pis,log_likelihood_Heads)
plot(pis,lLHeads)
plot(pis,lLHeads,'l')
plot(pis,lLHeads,'l', main='log-likelihood function')
pis=seq(0.01,1,0.001)
lLHeads=sapply(pis,log_likelihood_Heads)
plot(pis,lLHeads,'l', main='log-likelihood function')
pis=seq(0.001,1,0.001)
lLHeads=sapply(pis,log_likelihood_Heads)
plot(pis,lLHeads,'l', main='log-likelihood function')
pis=seq(0.005,1,0.001)
lLHeads=sapply(pis,log_likelihood_Heads)
plot(pis,lLHeads,'l', main='log-likelihood function')
plot(pis,lLHeads,'l', main='log-likelihood function',xlab = 'Pi',ylab = 'log-likelihood')
pbeta(pis,5,5)
priori=pbeta(pis,5,5)
plot(pis,priori,'l', main='function a priori',xlab = 'Pi',ylab = 'Beta distribution')
?pbeta(pis,5,5)
priori=dbeta(pis,5,5)
plot(pis,priori,'l', main='function a priori',xlab = 'Pi',ylab = 'Beta distribution')
plot(pis,priori,'l', main='Prior function',xlab = 'Pi',ylab = 'Beta distribution')
post=dbeta(pis,16,14)
plot(pis,post,'l', main='Prosterior function',xlab = 'Pi',ylab = 'Beta distribution')
plot(pis,priori,'l', main='Prior function',xlab = 'Pi',ylab = 'Density')
plot(pis,post,'l', main='Prosterior function',xlab = 'Pi',ylab = 'Density')
plot(pis,priori,'l', main='Prior function',xlab = 'Pi',ylab = 'Density')
line(pis,post,'l')
lines(pis,post,'l')
lines(pis,priori,'l')
plot(pis,post,'l', main='Prior function',xlab = 'Pi',ylab = 'Density')
lines(pis,priori,'l')
plot(pis,post,'l', main='Prior and Posterior functions',xlab = 'Pi',ylab = 'Density', col='blue')
lines(pis,priori,'l', col='red')
plot(pis,post,'l', main='Prior and Posterior functions',xlab = 'Pi',ylab = 'Density', col='red')
lines(pis,priori,'l', col='blue')
legend("bottomright", legend = c('blue',"red"),
lwd = 3, col = c('blue',"red"))
legend( legend = c('blue',"red"),
lwd = 3, col = c('blue',"red"))
?legend("bottomright", legend = c('blue',"red"),
lwd = 3, col = c('blue',"red"))
legend("upperright", legend = c('blue',"red"),
lwd = 3, col = c('blue',"red"))
legend("topright", legend = c('blue',"red"),
lwd = 3, col = c('blue',"red"))
plot(pis,post,'l', main='Prior and Posterior functions',xlab = 'Pi',ylab = 'Density', col='red')
lines(pis,priori,'l', col='blue')
legend("topright", legend = c('blue',"red"),
lwd = 3, col = c('blue',"red"))
legend("topright", legend = c('Prior',"Posterior"),
lwd = 3, col = c('blue',"red"))
postU=dbeta(pis,16,14)
plot(pis,post,'l', main='Prior and Posterior functions',xlab = 'Pi',ylab = 'Density', col='blue')
postU=dbeta(pis,12,10)
plot(pis,post,'l', main='Prior and Posterior functions',xlab = 'Pi',ylab = 'Density', col='blue')
lines(pis,postU,'l', col='red')
legend("topright", legend = c('Posterior with information',"Posterior with Uniform"),
lwd = 3, col = c('blue',"red"))
legend("topright", legend = c('Posterior with information',"Posterior with Uniform"),
lwd = 1, col = c('blue',"red"))
legend("topright", legend = c('Posterior with information',"Posterior with Uniform"),
lwd = 3, col = c('blue',"red"))
legend("topright", legend = c('Posterior with information',"Posterior with Uniform"),
lwd = 3, col = c('blue',"red"), border = NULL)
legend("topright", legend = c('Posterior with information',"Posterior with Uniform"),
lwd = 3, col = c('blue',"red"), border = 'NULL')
plot(pis,post,'l', main='Prior and Posterior functions',xlab = 'Pi',ylab = 'Density', col='blue')
lines(pis,postU,'l', col='red')
legend("topright", legend = c('Posterior with information',"Posterior with Uniform"),
lwd = 3, col = c('blue',"red"), border = NULL)
plot(pis,post,'l', main='Prior and Posterior functions',xlab = 'Pi',ylab = 'Density', col='blue')
lines(pis,postU,'l', col='red')
legend("topright", legend = c('Posterior with information',"Posterior with Uniform"),
lwd = 3, col = c('blue',"red"), border = 'NULL')
legend("topleft", legend = c('Posterior with information',"Posterior with Uniform"),
lwd = 3, col = c('blue',"red"), border = 'NULL')
legend("topleft", legend = c('Posterior with information',"Posterior with Uniform"),
lwd = 3, col = c('blue',"red"), bty = 'n')
plot(pis,post,'l', main='Prior and Posterior functions',xlab = 'Pi',ylab = 'Density', col='blue')
lines(pis,postU,'l', col='red')
legend("topleft", legend = c('Posterior with information',"Posterior with Uniform"),
lwd = 3, col = c('blue',"red"), bty = 'n')
legend("topright", legend = c('Posterior with information',"Posterior with Uniform"),
lwd = 3, col = c('blue',"red"), bty = 'n')
plot(pis,post,'l', main='Prior and Posterior functions',xlab = 'Pi',ylab = 'Density', col='blue')
lines(pis,postU,'l', col='red')
legend("topleft", legend = c('Posterior with information',"Posterior with Uniform"),
lwd = 3, col = c('blue',"red"), bty = 'n')
plot(pis,post,'l', main='Posterior functions',xlab = 'Pi',ylab = 'Density', col='blue')
lines(pis,postU,'l', col='red')
legend("topleft", legend = c('Posterior with information',"Posterior with Uniform"),
lwd = 3, col = c('blue',"red"), bty = 'n')
plot(pis,post/postU)
plot(pis,postU/post)
plot(pis,post/postU)
plot(pis,post/postU,'l', main="Bayes' factor Posterior functions",xlab = 'Pi',ylab = 'Ratio')
convexf=function(t){
1/(t+1)**2
}
ts=seq(0,100,1)
plot(ts,sapply(ts,convexf),'l', main="Density function of Convex example",xlab = 't',ylab = 'Density')
ts=seq(0,50,1)
plot(ts,sapply(ts,convexf),'l', main="Density function of Convex example",xlab = 't',ylab = 'Density')
ts=seq(0,10,1)
plot(ts,sapply(ts,convexf),'l', main="Density function of Convex example",xlab = 't',ylab = 'Density')
ts=seq(0,10,0.1)
plot(ts,sapply(ts,convexf),'l', main="Density function of Convex example",xlab = 't',ylab = 'Density')
plot(ts,sapply(ts,convexf),'l', main="Reliability function of convex example",xlab = 't',ylab = 'Density')
convexh=function(t){
1/(t+1)
}
plot(ts,sapply(ts,convexh),'l', main="Hazard function of convex example",xlab = 't',ylab = 'Density')
plot(ts,sapply(ts,convexR),'l', main="Reliability function of convex example",xlab = 't',ylab = 'R(t)')
convexR=function(t){
1/(t+1)**2
}
ts=seq(0,10,0.1)
plot(ts,sapply(ts,convexR),'l', main="Reliability function of convex example",xlab = 't',ylab = 'R(t)')
plot(ts,sapply(ts,convexh),'l', main="Hazard function of convex example",xlab = 't',ylab = 'h(t)')
concaveR=function(t){
-4/9*x**2+1
}
ts=seq(0,10,0.1)
ts=seq(0,1.5,0.1)
plot(ts,sapply(ts,concaveR),'l', main="Reliability function of concave example",xlab = 't',ylab = 'R(t)')
concaveh=function(t){
-8*t/(4*t**2-9)
}
concaveR=function(t){
-4/9*t**2+1
}
ts=seq(0,1.5,0.1)
plot(ts,sapply(ts,concaveR),'l', main="Reliability function of concave example",xlab = 't',ylab = 'R(t)')
concaveh=function(t){
-8*t/(4*t**2-9)
}
plot(ts,sapply(ts,concaveh),'l', main="Hazard function of concave example",xlab = 't',ylab = 'h(t)')
ts=seq(0,1.5,0.01)
plot(ts,sapply(ts,concaveR),'l', main="Reliability function of concave example",xlab = 't',ylab = 'R(t)')
concaveh=function(t){
-8*t/(4*t**2-9)
}
plot(ts,sapply(ts,concaveh),'l', main="Hazard function of concave example",xlab = 't',ylab = 'h(t)')
FailureTimes_5=read.csv('FailureTimes_5.csv',sep = ',')
FailureTimes_5=read.csv('FailureTimes_5.csv',sep = ',')
data=FailureTimes_5$Heures
#Necesario haber confirmado que funcione la función exponencial, si no, cambiar
rateU=1/mean(data)
scenarios=5000
n=100
set.seed(111)
U=rexp(n*scenarios, rate=rateU)
U=matrix(U,nrow = n, ncol = scenarios)
rateD=1/mean(data)/0.2
set.seed(222)
D=rexp(n*scenarios, rate=rateD)
D=matrix(D,nrow = n, ncol = scenarios)
##### Une Seul produit ####
U1=U[,1]
D1=D[,1]
r1=U1+D1
R1=cumsum(r1)
P1=R1-D1
t=seq(0,R1[n],100)
Disp=rep(0, length(t))
works=function(t){
sum(P1<=t)==sum(R1<=t)
}
Disp=sapply(t,works)
plot(t,Disp, type = "s", main="Disponibilité du premier produit dans le temps")
##### Generic ####
r=U+D
R=apply(r, 2, cumsum)
P=R-D
t=seq(0,max(R[n,]),100)
reparation=function(t){ #Products in reparation
sum(P<=t)-sum(R<=t)
}
reparation(10000)
Disp=(scenarios-sapply(t,reparation))/scenarios
plot(t,Disp, type = 'l' ,xlim=c(0, 5*10e3), ylim=c(0.5,1), main='Disponibilit? de produit dans le temps (A(t))')
(1/rateU)/(1/rateU+1/rateD) #Debe converger a este valor.
plot(t,Disp, type = 'l' ,xlim=c(0, 5*10e3), ylim=c(0.5,1),label='Simulation', main='Disponibilité de produit dans le temps (A(t))')
line(t,As, type = 'l' , label='Valeur théorique')
lines(t,As, type = 'l' , label='Valeur théorique')
A=function(t){ #Products in reparation
1/(rateU+rateD)*(rateD+rateU*exp(-(rateD+rateU)*t))
}
As=sapply(t,A)
lines(t,As, type = 'l' , label='Valeur théorique')
(1/rateU)/(1/rateU+1/rateD) #Debe converger a este valor.
plot(t,Disp, type = 'l' ,xlim=c(0, 5*10e3), ylim=c(0.8,1),label='Simulation', main='Disponibilité de produit dans le temps (A(t))')
lines(t,As, type = 'l' , label='Valeur théorique')
plot(t,Disp, type = 'l' ,xlim=c(0, 5*10e3), ylim=c(0.7,1),label='Simulation', main='Disponibilité de produit dans le temps (A(t))')
lines(t,As, type = 'l' , label='Valeur théorique')
legend("topright", legend = c('Simulation Montecarlo',"Valeur théorique"),
lwd = 3, col = c('blue',"red"), bty = 'n')
plot(t,Disp, type = 'l' ,xlim=c(0, 5*10e3), ylim=c(0.7,1),col='blue', main='Disponibilité de produit dans le temps (A(t))')
lines(t,As, type = 'l' , col='red', label='Valeur théorique')
legend("topright", legend = c('Simulation Montecarlo',"Valeur théorique"),
lwd = 3, col = c('blue',"red"), bty = 'n')
legend("topright", legend = c('Simulation Montecarlo',"Valeur théorique"),
lwd = 2, col = c('blue',"red"), bty = 'n')
legend("topright", legend = c('Simulation Montecarlo',"Valeur théorique"),
lwd = 2, col = c('blue',"red"), bty = 'n')
plot(t,Disp, type = 'l' ,xlim=c(0, 5*10e3), ylim=c(0.7,1),col='blue', main='Disponibilité de produit dans le temps (A(t))')
lines(t,As, type = 'l' , col='red', label='Valeur théorique')
legend("topright", legend = c('Simulation Montecarlo',"Valeur théorique"),
lwd = 2, col = c('blue',"red"), bty = 'n')
plot(t,Disp, type = 'l' ,xlim=c(0, 5*10e3), ylim=c(0.7,1),col='blue', main='Disponibilité de produit dans le temps',ylab='A(t)')
lines(t,As, type = 'l' , col='red', label='Valeur théorique')
legend("topright", legend = c('Simulation Montecarlo',"Valeur théorique"),
lwd = 2, col = c('blue',"red"), bty = 'n')
plot(t,Disp, type = 'l' ,xlim=c(0, 5*10e3), ylim=c(0.7,1),col='blue', main='Disponibilité de produit dans le temps',ylab='A(t)')
lines(t,As, type = 'l' , col='red', label='Valeur théorique')
legend("topright", legend = c('Simulation Montecarlo',"Valeur théorique"),
lwd = 2, col = c('blue',"red"), bty = 'n')
View(FailureTimes_5)
library(car)
library(MASS)
library(nortest)
FailureTimes_5=read.csv('FailureTimes_5.csv',sep = ',')
data=FailureTimes_5$Heures
FailureTimes_5=read.csv('FailureTimes_5.csv',sep = ',')
data=FailureTimes_5$Heures
hist(data, freq = FALSE,breaks = 9)
hist(data, freq = FALSE,breaks = 9, main='Histogramme de temps de panne')
#### Exponential distribution ####
qqPlot(data, distribution = "exp", rate = 1/mean(data), main='Quantile-Quantile Plot of data with Exponential distribution')
ks.test(data,"pexp",rate=1/mean(data))
hist(data, freq = FALSE, ylim = c(0,0.0002), main="Data avec exponential distribution")
curve(dexp(x, rate = 1/mean(data)), from=0, to=max(data), col='blue', add=TRUE)
#### Exponential distribution ####
qqPlot(data, distribution = "exp", rate = 1/mean(data), main='Quantile-Quantile Plot of temps de panne with Exponential distribution')
ks.test(data,"pexp",rate=1/mean(data))
#### Exponential distribution ####
qqPlot(data, distribution = "exp", rate = 1/mean(data), main='Quantile-Quantile Plot de temps de panne avec distribution Exponentielle')
hist(data, freq = FALSE, ylim = c(0,0.0002), main="Temps de panne avec distribution Exponentielle")
curve(dexp(x, rate = 1/mean(data)), from=0, to=max(data), col='blue', add=TRUE)
log.likelihoodWEIBULL= function(tetha){
beta=tetha[1]
lambda=tetha[2]
l=dweibull(data,beta,1/lambda)
return(-sum(log(l)))
}
SolW=nlminb(c(0.001,2),log.likelihoodWEIBULL, hessian = TRUE)
SolW #Code debe dar 1 o 2
betaHatW=SolW$par[1]
lambdaHatW=SolW$par[2]
qqPlot(data, distribution = "weibull", shape=betaHatW, scale=1/lambdaHatW , main='Quantile-Quantile Plot of data with Weibull distribution')
ks.test(data,"pweibull",shape=betaHatW,scale=1/lambdaHatW)
qqPlot(data, distribution = "weibull", shape=betaHatW, scale=1/lambdaHatW , main='Quantile-Quantile Plot de temps de panne avec distribution Weibull')
ks.test(data,"pweibull",shape=betaHatW,scale=1/lambdaHatW)
qqPlot(data, distribution = "weibull", shape=betaHatW, scale=1/lambdaHatW , main='Quantile-Quantile Plot de temps de panne avec distribution Weibull')
ks.test(data,"pweibull",shape=betaHatW,scale=1/lambdaHatW)
hist(data, freq = FALSE, ylim = c(0,0.0002), main="Temps de panne avec distribution Weibull")
curve(dweibull(x, shape=betaHatW, scale=1/lambdaHatW), from=0, to=max(data), col='blue', add=TRUE)
forma=mean(data)**2/var(data)
escala=mean(data)/forma
qqPlot(data, distribution = "gamma", scale = escala, shape = forma, main='Quantile-Quantile Plot of data with Gamma distribution')
qqPlot(data, distribution = "gamma", scale = escala, shape = forma, main='Quantile-Quantile Plot de temps de panne avec distribution Gamma')
ks.test(data,"pgamma",scale = escala, shape = forma)
hist(data, freq = FALSE, ylim = c(0,0.0002), main="Temps de panne avec distribution Gamma")
curve(dgamma(x, scale = escala, shape = forma), from=0, to=max(data), col='blue', add=TRUE)
data1=c(1770,2448,3230,3445)
data2=c(1090,1907,2147,2645,2903)
data3=c(630,848,1121,1307,1321,1357,1984,2331)
S0=50
S1=80
S2=100
S3=120
n1=12
n2=10
n3=8
r1=length(data1)
r2=length(data2)
C1=3500
C2=3000
log.likelihood= function(theta){
b0=theta[1]
b1=theta[2]
l=r1*(b0+b1*S1)-exp(b0+b1*S1)*sum(data1)-exp(b0+b1*S1)*(n1-r1)*C1 + r2*(b0+b1*S2)-exp(b0+b1*S2)*sum(data2)-exp(b0+b1*S2)*(n2-r2)*C2 + n3*(b0+b1*S3)-exp(b0+b1*S3)*sum(data3)
return(-l)
}
log.likelihood(c(-0.01,-0.1))
Sol=nlm(log.likelihood,c(0.5,-0.001), hessian = TRUE)
Sol #Code debe dar 1 o 2
beta0Hat=Sol$estimate[1]
beta1Hat=Sol$estimate[2]
log.likelihood(c(beta0Hat,beta1Hat))
exp(beta0Hat+beta1Hat*S0)
1/exp(beta0Hat+beta1Hat*S0)
1500*exp(beta0Hat+beta1Hat*S2)/exp(beta0Hat+beta1Hat*S0)
1500*exp(beta0Hat+beta1Hat*S3)/exp(beta0Hat+beta1Hat*S0)
?dlnorm
#### Chi-Squared distribution ####
solLN=fitdistr(data, "chi-squared",start=list(df=3) )
dfCh=solLN$estimate[1]
qqPlot(data, distribution = "chisq", df=dfCh, main='Quantile-Quantile Plot de temps de panne avec distribution Chi-Squared')
ks.test(data,"pchisq",df =  dfCh)
hist(data, freq = FALSE, ylim = c(0,0.0002), main="Temps de panne avec distribution Chi-Squared")
curve(dchisq(x, df =  dfCh), from=0, to=max(data), col='blue', add=TRUE)
dfCh
#### Chi-Squared distribution ####
solLN=fitdistr(data, "chi-squared",start=list(df=3000) )
solLN$estimate
dfCh=solLN$estimate[1]
qqPlot(data, distribution = "chisq", df=dfCh, main='Quantile-Quantile Plot de temps de panne avec distribution Chi-Squared')
ks.test(data,"pchisq",df =  dfCh)
hist(data, freq = FALSE, ylim = c(0,0.0002), main="Temps de panne avec distribution Chi-Squared")
curve(dchisq(x, df =  dfCh), from=0, to=max(data), col='blue', add=TRUE)
#### Normal distribution ####
qqPlot(data, distribution = "norm", df=dfCh, main='Quantile-Quantile Plot de temps de panne avec distribution Normal')
?pnorm()
sd(data)
var(data)
sd(data)**2
#### Normal distribution ####
qqPlot(data, distribution = "norm", mean=mean(data),sd=sd(data), main='Quantile-Quantile Plot de temps de panne avec distribution Normal')
ks.test(data,"pnorm",df =  dfCh)
ks.test(data,"pnorm", mean=mean(data),sd=sd(data))
hist(data, freq = FALSE, ylim = c(0,0.0002), main="Temps de panne avec distribution Chi-Squared")
curve(dnorm(x, df =  dfCh), from=0, to=max(data), col='blue', add=TRUE)
curve(dnorm(x, mean=mean(data),sd=sd(data)), from=0, to=max(data), col='blue', add=TRUE)
#### LogNormal distribution ####
solLN=fitdistr(data, "log-normal")
#mlog=log(mean(data)/sqrt(var(data)/mean(data)**2 + 1))
#stdlog=sqrt(log(var(data)/mean(data)**2 + 1))
mlog=solLN$estimate[1]
stdlog=solLN$estimate[2]
qqPlot(data, distribution = "lnorm",meanlog =  mlog, sdlog=stdlog, main='Quantile-Quantile Plot de temps de panne avec distribution Log-Normal')
ks.test(data,"plnorm",meanlog =  mlog, sdlog=stdlog)
hist(data, freq = FALSE, ylim = c(0,0.0002), main="Temps de panne avec distribution Log-Normal")
curve(dlnorm(x, meanlog =  mlog, sdlog=stdlog), from=0, to=max(data), col='blue', add=TRUE)
#### Chi-Squared distribution ####
solLN=fitdistr(data, "chi-squared",start=list(df=3000) )
dfCh=solLN$estimate[1]
qqPlot(data, distribution = "chisq", df=dfCh, main='Quantile-Quantile Plot de temps de panne avec distribution Chi-Squared')
ks.test(data,"pchisq",df =  dfCh)
qqPlot(data, distribution = "chisq", df=dfCh, main='Quantile-Quantile Plot de temps de panne avec distribution Chi-Squared')
ks.test(data,"pchisq",df =  dfCh)
hist(data, freq = FALSE, ylim = c(0,0.0002), main="Temps de panne avec distribution Chi-Squared")
curve(dchisq(x, df =  dfCh), from=0, to=max(data), col='blue', add=TRUE)
#### Normal distribution ####
qqPlot(data, distribution = "norm", mean=mean(data),sd=sd(data), main='Quantile-Quantile Plot de temps de panne avec distribution Normal')
ks.test(data,"pnorm", mean=mean(data),sd=sd(data))
hist(data, freq = FALSE, ylim = c(0,0.0002), main="Temps de panne avec distribution Normal")
curve(dnorm(x, mean=mean(data),sd=sd(data)), from=0, to=max(data), col='blue', add=TRUE)
#### Exponential distribution ####
qqPlot(data, distribution = "exp", rate = 1/mean(data), main='Quantile-Quantile Plot de temps de panne avec distribution Exponentielle')
ks.test(data,"pexp",rate=1/mean(data))
qqPlot(data, distribution = "weibull", shape=betaHatW, scale=1/lambdaHatW , main='Quantile-Quantile Plot de temps de panne avec distribution Weibull')
ks.test(data,"pweibull",shape=betaHatW,scale=1/lambdaHatW)
FailureTimes_5=read.csv('FailureTimes_5.csv',sep = ',')
data=FailureTimes_5$Heures
#Necesario haber confirmado que funcione la función exponencial, si no, cambiar
rateU=1/mean(data)
scenarios=5000
n=100
set.seed(111)
U=rexp(n*scenarios, rate=rateU)
U=matrix(U,nrow = n, ncol = scenarios)
rateD=1/mean(data)/0.2
set.seed(222)
D=rexp(n*scenarios, rate=rateD)
D=matrix(D,nrow = n, ncol = scenarios)
##### Une Seul produit ####
U1=U[,1]
D1=D[,1]
r1=U1+D1
R1=cumsum(r1)
P1=R1-D1
t=seq(0,R1[n],100)
Disp=rep(0, length(t))
works=function(t){
sum(P1<=t)==sum(R1<=t)
}
Disp=sapply(t,works)
plot(t,Disp, type = "s", main="Disponibilité du premier produit dans le temps")
##### Generic ####
r=U+D
R=apply(r, 2, cumsum)
P=R-D
t=seq(0,max(R[n,]),100)
reparation=function(t){ #Products in reparation
sum(P<=t)-sum(R<=t)
}
reparation(10000)
Disp=(scenarios-sapply(t,reparation))/scenarios
plot(t,Disp, type = 'l' ,xlim=c(0, 5*10e3), ylim=c(0.5,1), main='Disponibilité de produit dans le temps',ylab='A(t)')
(1/rateU)/(1/rateU+1/rateD) #Debe converger a este valor.
A=function(t){ #Products in reparation
1/(rateU+rateD)*(rateD+rateU*exp(-(rateD+rateU)*t))
}
As=sapply(t,A)
plot(t,Disp, type = 'l' ,xlim=c(0, 5*10e3), ylim=c(0.7,1),col='blue', main='Disponibilité de produit dans le temps',ylab='A(t)')
lines(t,As, type = 'l' , col='red', label='Valeur théorique')
legend("topright", legend = c('Simulation Montecarlo',"Valeur théorique"),
lwd = 2, col = c('blue',"red"), bty = 'n')
FailureTimes_5=read.csv('FailureTimes_5.csv',sep = ',')
data=FailureTimes_5$Heures
rateU=1/mean(data)
rateD=1/mean(data)/0.2
rateU
rateD
(Disp-As)**2
FailureTimes_5=read.csv('FailureTimes_5.csv',sep = ',')
data=FailureTimes_5$Heures
#Necesario haber confirmado que funcione la función exponencial, si no, cambiar
rateU=1/mean(data)
scenarios=5000
n=100
set.seed(111)
U=rexp(n*scenarios, rate=rateU)
U=matrix(U,nrow = n, ncol = scenarios)
rateD=1/mean(data)/0.2
set.seed(222)
D=rexp(n*scenarios, rate=rateD)
D=matrix(D,nrow = n, ncol = scenarios)
##### Une Seul produit ####
U1=U[,1]
D1=D[,1]
r1=U1+D1
R1=cumsum(r1)
P1=R1-D1
t=seq(0,R1[n],100)
Disp=rep(0, length(t))
works=function(t){
sum(P1<=t)==sum(R1<=t)
}
Disp=sapply(t,works)
plot(t,Disp, type = "s", main="Disponibilité du premier produit dans le temps")
##### Generic ####
r=U+D
R=apply(r, 2, cumsum)
P=R-D
t=seq(0,max(R[n,]),100)
reparation=function(t){ #Products in reparation
sum(P<=t)-sum(R<=t)
}
reparation(10000)
Disp=(scenarios-sapply(t,reparation))/scenarios
plot(t,Disp, type = 'l' ,xlim=c(0, 5*10e3), ylim=c(0.5,1), main='Disponibilité de produit dans le temps',ylab='A(t)')
(1/rateU)/(1/rateU+1/rateD) #Debe converger a este valor.
A=function(t){ #Products in reparation
1/(rateU+rateD)*(rateD+rateU*exp(-(rateD+rateU)*t))
}
As=sapply(t,A)
plot(t,Disp, type = 'l' ,xlim=c(0, 5*10e3), ylim=c(0.7,1),col='blue', main='Disponibilité de produit dans le temps',ylab='A(t)')
lines(t,As, type = 'l' , col='red', label='Valeur théorique')
legend("topright", legend = c('Simulation Montecarlo',"Valeur théorique"),
lwd = 2, col = c('blue',"red"), bty = 'n')
(Disp-As)**2
t[1000]
plot(t,Disp, type = 'l' , ylim=c(0.7,1),col='blue', main='Disponibilité de produit dans le temps',ylab='A(t)')
t[10000]
t[1000]
5*10e5
5e5
sum(t<5e5)
t[5000]
Disp[:5000]
Disp[0:5000]
abs(Disp[0:5000]-As[0:5000])
(Disp[0:5000]-As[0:5000])
mean(abs(Disp[0:5000]-As[0:5000])/As[0:5000])
